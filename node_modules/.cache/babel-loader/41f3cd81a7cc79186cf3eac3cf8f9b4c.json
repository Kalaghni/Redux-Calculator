{"ast":null,"code":"import { contains } from './array.js';\nimport { pickShallow } from './object.js';\n/**\r\n * Create a factory function, which can be used to inject dependencies.\r\n *\r\n * The created functions are memoized, a consecutive call of the factory\r\n * with the exact same inputs will return the same function instance.\r\n * The memoized cache is exposed on `factory.cache` and can be cleared\r\n * if needed.\r\n *\r\n * Example:\r\n *\r\n *     const name = 'log'\r\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\r\n *\r\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\r\n *       // ... create the function log here and return it\r\n *     }\r\n *\r\n * @param {string} name           Name of the function to be created\r\n * @param {string[]} dependencies The names of all required dependencies\r\n * @param {function} create       Callback function called with an object with all dependencies\r\n * @param {Object} [meta]         Optional object with meta information that will be attached\r\n *                                to the created factory function as property `meta`.\r\n * @returns {function}\r\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\r\n * Sort all factories such that when loading in order, the dependencies are resolved.\r\n *\r\n * @param {Array} factories\r\n * @returns {Array} Returns a new array with the sorted factories.\r\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\r\n * Test whether an object is a factory. This is the case when it has\r\n * properties name, dependencies, and a function create.\r\n * @param {*} obj\r\n * @returns {boolean}\r\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\r\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\r\n *\r\n * Will throw an exception when there are dependencies missing.\r\n *\r\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\r\n * @param {string[]} dependencies\r\n * @param {Object} scope\r\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"names":["contains","pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"sources":["C:/laragon/www/testsite.thewateringcan/wp-content/plugins/Redux-Calculator/node_modules/mathjs/lib/esm/utils/factory.js"],"sourcesContent":["import { contains } from './array.js';\r\nimport { pickShallow } from './object.js';\r\n/**\r\n * Create a factory function, which can be used to inject dependencies.\r\n *\r\n * The created functions are memoized, a consecutive call of the factory\r\n * with the exact same inputs will return the same function instance.\r\n * The memoized cache is exposed on `factory.cache` and can be cleared\r\n * if needed.\r\n *\r\n * Example:\r\n *\r\n *     const name = 'log'\r\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\r\n *\r\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\r\n *       // ... create the function log here and return it\r\n *     }\r\n *\r\n * @param {string} name           Name of the function to be created\r\n * @param {string[]} dependencies The names of all required dependencies\r\n * @param {function} create       Callback function called with an object with all dependencies\r\n * @param {Object} [meta]         Optional object with meta information that will be attached\r\n *                                to the created factory function as property `meta`.\r\n * @returns {function}\r\n */\r\n\r\nexport function factory(name, dependencies, create, meta) {\r\n  function assertAndCreate(scope) {\r\n    // we only pass the requested dependencies to the factory function\r\n    // to prevent functions to rely on dependencies that are not explicitly\r\n    // requested.\r\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\r\n    assertDependencies(name, dependencies, scope);\r\n    return create(deps);\r\n  }\r\n\r\n  assertAndCreate.isFactory = true;\r\n  assertAndCreate.fn = name;\r\n  assertAndCreate.dependencies = dependencies.slice().sort();\r\n\r\n  if (meta) {\r\n    assertAndCreate.meta = meta;\r\n  }\r\n\r\n  return assertAndCreate;\r\n}\r\n/**\r\n * Sort all factories such that when loading in order, the dependencies are resolved.\r\n *\r\n * @param {Array} factories\r\n * @returns {Array} Returns a new array with the sorted factories.\r\n */\r\n\r\nexport function sortFactories(factories) {\r\n  var factoriesByName = {};\r\n  factories.forEach(factory => {\r\n    factoriesByName[factory.fn] = factory;\r\n  });\r\n\r\n  function containsDependency(factory, dependency) {\r\n    // TODO: detect circular references\r\n    if (isFactory(factory)) {\r\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\r\n        return true;\r\n      }\r\n\r\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  var sorted = [];\r\n\r\n  function addFactory(factory) {\r\n    var index = 0;\r\n\r\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\r\n      index++;\r\n    }\r\n\r\n    sorted.splice(index, 0, factory);\r\n  } // sort regular factory functions\r\n\r\n\r\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\r\n\r\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\r\n  return sorted;\r\n} // TODO: comment or cleanup if unused in the end\r\n\r\nexport function create(factories) {\r\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  sortFactories(factories).forEach(factory => factory(scope));\r\n  return scope;\r\n}\r\n/**\r\n * Test whether an object is a factory. This is the case when it has\r\n * properties name, dependencies, and a function create.\r\n * @param {*} obj\r\n * @returns {boolean}\r\n */\r\n\r\nexport function isFactory(obj) {\r\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\r\n}\r\n/**\r\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\r\n *\r\n * Will throw an exception when there are dependencies missing.\r\n *\r\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\r\n * @param {string[]} dependencies\r\n * @param {Object} scope\r\n */\r\n\r\nexport function assertDependencies(name, dependencies, scope) {\r\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\r\n  .every(dependency => scope[dependency] !== undefined);\r\n\r\n  if (!allDefined) {\r\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined); // TODO: create a custom error class for this, a MathjsError or something like that\r\n\r\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\r\n  }\r\n}\r\nexport function isOptionalDependency(dependency) {\r\n  return dependency && dependency[0] === '?';\r\n}\r\nexport function stripOptionalNotation(dependency) {\r\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}