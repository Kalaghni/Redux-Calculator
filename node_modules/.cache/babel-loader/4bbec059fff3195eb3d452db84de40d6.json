{"ast":null,"code":"import { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\r\n   * @constructor RangeNode\r\n   * @extends {Node}\r\n   * create a range\r\n   * @param {Node} start  included lower-bound\r\n   * @param {Node} end    included upper-bound\r\n   * @param {Node} [step] optional step\r\n   */\n\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!isNode(start)) throw new TypeError('Node expected');\n    if (!isNode(end)) throw new TypeError('Node expected');\n    if (step && !isNode(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\r\n   * Check whether the RangeNode needs the `end` symbol to be defined.\r\n   * This end is the size of the Matrix in current dimension.\r\n   * @return {boolean}\r\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return isSymbolNode(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\r\n   * Create a new RangeNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {RangeNode} Returns a transformed copy of the node\r\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {RangeNode}\r\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\r\n   * Calculate the necessary parentheses\r\n   * @param {Node} node\r\n   * @param {string} parenthesis\r\n   * @return {Object} parentheses\r\n   * @private\r\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\r\n   * Instantiate an RangeNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {RangeNode}\r\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\r\n   * Get LaTeX representation\r\n   * @params {Object} options\r\n   * @return {string} str\r\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","RangeNode","start","end","step","SyntaxError","TypeError","arguments","length","Error","prototype","type","isRangeNode","needsEnd","endSymbols","filter","node","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","calculateNecessaryParentheses","parenthesis","precedence","parens","startPrecedence","stepPrecedence","endPrecedence","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"sources":["C:/laragon/www/testsite.thewateringcan/wp-content/plugins/Redux-Calculator/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"sourcesContent":["import { isNode, isSymbolNode } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { getPrecedence } from '../operators.js';\r\nvar name = 'RangeNode';\r\nvar dependencies = ['Node'];\r\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n\r\n  /**\r\n   * @constructor RangeNode\r\n   * @extends {Node}\r\n   * create a range\r\n   * @param {Node} start  included lower-bound\r\n   * @param {Node} end    included upper-bound\r\n   * @param {Node} [step] optional step\r\n   */\r\n  function RangeNode(start, end, step) {\r\n    if (!(this instanceof RangeNode)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    } // validate inputs\r\n\r\n\r\n    if (!isNode(start)) throw new TypeError('Node expected');\r\n    if (!isNode(end)) throw new TypeError('Node expected');\r\n    if (step && !isNode(step)) throw new TypeError('Node expected');\r\n    if (arguments.length > 3) throw new Error('Too many arguments');\r\n    this.start = start; // included lower-bound\r\n\r\n    this.end = end; // included upper-bound\r\n\r\n    this.step = step || null; // optional step\r\n  }\r\n\r\n  RangeNode.prototype = new Node();\r\n  RangeNode.prototype.type = 'RangeNode';\r\n  RangeNode.prototype.isRangeNode = true;\r\n  /**\r\n   * Check whether the RangeNode needs the `end` symbol to be defined.\r\n   * This end is the size of the Matrix in current dimension.\r\n   * @return {boolean}\r\n   */\r\n\r\n  RangeNode.prototype.needsEnd = function () {\r\n    // find all `end` symbols in this RangeNode\r\n    var endSymbols = this.filter(function (node) {\r\n      return isSymbolNode(node) && node.name === 'end';\r\n    });\r\n    return endSymbols.length > 0;\r\n  };\r\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\r\n\r\n\r\n  RangeNode.prototype._compile = function (math, argNames) {\r\n    var range = math.range;\r\n\r\n    var evalStart = this.start._compile(math, argNames);\r\n\r\n    var evalEnd = this.end._compile(math, argNames);\r\n\r\n    if (this.step) {\r\n      var evalStep = this.step._compile(math, argNames);\r\n\r\n      return function evalRangeNode(scope, args, context) {\r\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\r\n      };\r\n    } else {\r\n      return function evalRangeNode(scope, args, context) {\r\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\r\n      };\r\n    }\r\n  };\r\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\r\n\r\n\r\n  RangeNode.prototype.forEach = function (callback) {\r\n    callback(this.start, 'start', this);\r\n    callback(this.end, 'end', this);\r\n\r\n    if (this.step) {\r\n      callback(this.step, 'step', this);\r\n    }\r\n  };\r\n  /**\r\n   * Create a new RangeNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {RangeNode} Returns a transformed copy of the node\r\n   */\r\n\r\n\r\n  RangeNode.prototype.map = function (callback) {\r\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\r\n  };\r\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {RangeNode}\r\n   */\r\n\r\n\r\n  RangeNode.prototype.clone = function () {\r\n    return new RangeNode(this.start, this.end, this.step && this.step);\r\n  };\r\n  /**\r\n   * Calculate the necessary parentheses\r\n   * @param {Node} node\r\n   * @param {string} parenthesis\r\n   * @return {Object} parentheses\r\n   * @private\r\n   */\r\n\r\n\r\n  function calculateNecessaryParentheses(node, parenthesis) {\r\n    var precedence = getPrecedence(node, parenthesis);\r\n    var parens = {};\r\n    var startPrecedence = getPrecedence(node.start, parenthesis);\r\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\r\n\r\n    if (node.step) {\r\n      var stepPrecedence = getPrecedence(node.step, parenthesis);\r\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\r\n    }\r\n\r\n    var endPrecedence = getPrecedence(node.end, parenthesis);\r\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\r\n    return parens;\r\n  }\r\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\r\n\r\n\r\n  RangeNode.prototype._toString = function (options) {\r\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\r\n\r\n    var str;\r\n    var start = this.start.toString(options);\r\n\r\n    if (parens.start) {\r\n      start = '(' + start + ')';\r\n    }\r\n\r\n    str = start;\r\n\r\n    if (this.step) {\r\n      var step = this.step.toString(options);\r\n\r\n      if (parens.step) {\r\n        step = '(' + step + ')';\r\n      }\r\n\r\n      str += ':' + step;\r\n    }\r\n\r\n    var end = this.end.toString(options);\r\n\r\n    if (parens.end) {\r\n      end = '(' + end + ')';\r\n    }\r\n\r\n    str += ':' + end;\r\n    return str;\r\n  };\r\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  RangeNode.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'RangeNode',\r\n      start: this.start,\r\n      end: this.end,\r\n      step: this.step\r\n    };\r\n  };\r\n  /**\r\n   * Instantiate an RangeNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {RangeNode}\r\n   */\r\n\r\n\r\n  RangeNode.fromJSON = function (json) {\r\n    return new RangeNode(json.start, json.end, json.step);\r\n  };\r\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\r\n\r\n\r\n  RangeNode.prototype.toHTML = function (options) {\r\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\r\n\r\n    var str;\r\n    var start = this.start.toHTML(options);\r\n\r\n    if (parens.start) {\r\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n    }\r\n\r\n    str = start;\r\n\r\n    if (this.step) {\r\n      var step = this.step.toHTML(options);\r\n\r\n      if (parens.step) {\r\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n\r\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\r\n    }\r\n\r\n    var end = this.end.toHTML(options);\r\n\r\n    if (parens.end) {\r\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n    }\r\n\r\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\r\n    return str;\r\n  };\r\n  /**\r\n   * Get LaTeX representation\r\n   * @params {Object} options\r\n   * @return {string} str\r\n   */\r\n\r\n\r\n  RangeNode.prototype._toTex = function (options) {\r\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n    var parens = calculateNecessaryParentheses(this, parenthesis);\r\n    var str = this.start.toTex(options);\r\n\r\n    if (parens.start) {\r\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\r\n    }\r\n\r\n    if (this.step) {\r\n      var step = this.step.toTex(options);\r\n\r\n      if (parens.step) {\r\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\r\n      }\r\n\r\n      str += ':' + step;\r\n    }\r\n\r\n    var end = this.end.toTex(options);\r\n\r\n    if (parens.end) {\r\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\r\n    }\r\n\r\n    str += ':' + end;\r\n    return str;\r\n  };\r\n\r\n  return RangeNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}