{"ast":null,"code":"import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isNode, isObjectNode, isParenthesisNode, isSymbolNode } from '../../utils/is.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { accessFactory } from './utils/access.js';\nvar name = 'AccessorNode';\nvar dependencies = ['subset', 'Node'];\nexport var createAccessorNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var subset = _ref.subset,\n      Node = _ref.Node;\n  var access = accessFactory({\n    subset: subset\n  });\n  /**\r\n   * @constructor AccessorNode\r\n   * @extends {Node}\r\n   * Access an object property or get a matrix subset\r\n   *\r\n   * @param {Node} object                 The object from which to retrieve\r\n   *                                      a property or subset.\r\n   * @param {IndexNode} index             IndexNode containing ranges\r\n   */\n\n  function AccessorNode(object, index) {\n    if (!(this instanceof AccessorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(object)) {\n      throw new TypeError('Node expected for parameter \"object\"');\n    }\n\n    if (!isIndexNode(index)) {\n      throw new TypeError('IndexNode expected for parameter \"index\"');\n    }\n\n    this.object = object || null;\n    this.index = index; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        if (this.index) {\n          return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';\n        } else {\n          return this.object.name || '';\n        }\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  AccessorNode.prototype = new Node();\n  AccessorNode.prototype.type = 'AccessorNode';\n  AccessorNode.prototype.isAccessorNode = true;\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\n\n  AccessorNode.prototype._compile = function (math, argNames) {\n    var evalObject = this.object._compile(math, argNames);\n\n    var evalIndex = this.index._compile(math, argNames);\n\n    if (this.index.isObjectProperty()) {\n      var prop = this.index.getObjectProperty();\n      return function evalAccessorNode(scope, args, context) {\n        // get a property from an object evaluated using the scope.\n        return getSafeProperty(evalObject(scope, args, context), prop);\n      };\n    } else {\n      return function evalAccessorNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        var index = evalIndex(scope, args, object); // we pass object here instead of context\n\n        return access(object, index);\n      };\n    }\n  };\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\n\n\n  AccessorNode.prototype.forEach = function (callback) {\n    callback(this.object, 'object', this);\n    callback(this.index, 'index', this);\n  };\n  /**\r\n   * Create a new AccessorNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {AccessorNode} Returns a transformed copy of the node\r\n   */\n\n\n  AccessorNode.prototype.map = function (callback) {\n    return new AccessorNode(this._ifNode(callback(this.object, 'object', this)), this._ifNode(callback(this.index, 'index', this)));\n  };\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {AccessorNode}\r\n   */\n\n\n  AccessorNode.prototype.clone = function () {\n    return new AccessorNode(this.object, this.index);\n  };\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string}\r\n   */\n\n\n  AccessorNode.prototype._toString = function (options) {\n    var object = this.object.toString(options);\n\n    if (needParenthesis(this.object)) {\n      object = '(' + object + ')';\n    }\n\n    return object + this.index.toString(options);\n  };\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string}\r\n   */\n\n\n  AccessorNode.prototype.toHTML = function (options) {\n    var object = this.object.toHTML(options);\n\n    if (needParenthesis(this.object)) {\n      object = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + object + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return object + this.index.toHTML(options);\n  };\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string}\r\n   */\n\n\n  AccessorNode.prototype._toTex = function (options) {\n    var object = this.object.toTex(options);\n\n    if (needParenthesis(this.object)) {\n      object = '\\\\left(\\' + object + \\'\\\\right)';\n    }\n\n    return object + this.index.toTex(options);\n  };\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\n\n\n  AccessorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'AccessorNode',\n      object: this.object,\n      index: this.index\n    };\n  };\n  /**\r\n   * Instantiate an AccessorNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"AccessorNode\", object: ..., index: ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {AccessorNode}\r\n   */\n\n\n  AccessorNode.fromJSON = function (json) {\n    return new AccessorNode(json.object, json.index);\n  };\n  /**\r\n   * Are parenthesis needed?\r\n   * @private\r\n   */\n\n\n  function needParenthesis(node) {\n    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?\n    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));\n  }\n\n  return AccessorNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isIndexNode","isNode","isObjectNode","isParenthesisNode","isSymbolNode","getSafeProperty","factory","accessFactory","name","dependencies","createAccessorNode","_ref","subset","Node","access","AccessorNode","object","index","SyntaxError","TypeError","Object","defineProperty","get","isObjectProperty","getObjectProperty","bind","set","Error","prototype","type","_compile","math","argNames","evalObject","evalIndex","prop","evalAccessorNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","toString","needParenthesis","toHTML","_toTex","toTex","toJSON","mathjs","fromJSON","json","node","isClass"],"sources":["C:/laragon/www/testsite.thewateringcan/wp-content/plugins/Redux-Calculator/node_modules/mathjs/lib/esm/expression/node/AccessorNode.js"],"sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isNode, isObjectNode, isParenthesisNode, isSymbolNode } from '../../utils/is.js';\r\nimport { getSafeProperty } from '../../utils/customs.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { accessFactory } from './utils/access.js';\r\nvar name = 'AccessorNode';\r\nvar dependencies = ['subset', 'Node'];\r\nexport var createAccessorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    subset,\r\n    Node\r\n  } = _ref;\r\n  var access = accessFactory({\r\n    subset\r\n  });\r\n  /**\r\n   * @constructor AccessorNode\r\n   * @extends {Node}\r\n   * Access an object property or get a matrix subset\r\n   *\r\n   * @param {Node} object                 The object from which to retrieve\r\n   *                                      a property or subset.\r\n   * @param {IndexNode} index             IndexNode containing ranges\r\n   */\r\n\r\n  function AccessorNode(object, index) {\r\n    if (!(this instanceof AccessorNode)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n\r\n    if (!isNode(object)) {\r\n      throw new TypeError('Node expected for parameter \"object\"');\r\n    }\r\n\r\n    if (!isIndexNode(index)) {\r\n      throw new TypeError('IndexNode expected for parameter \"index\"');\r\n    }\r\n\r\n    this.object = object || null;\r\n    this.index = index; // readonly property name\r\n\r\n    Object.defineProperty(this, 'name', {\r\n      get: function () {\r\n        if (this.index) {\r\n          return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';\r\n        } else {\r\n          return this.object.name || '';\r\n        }\r\n      }.bind(this),\r\n      set: function set() {\r\n        throw new Error('Cannot assign a new name, name is read-only');\r\n      }\r\n    });\r\n  }\r\n\r\n  AccessorNode.prototype = new Node();\r\n  AccessorNode.prototype.type = 'AccessorNode';\r\n  AccessorNode.prototype.isAccessorNode = true;\r\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\r\n\r\n  AccessorNode.prototype._compile = function (math, argNames) {\r\n    var evalObject = this.object._compile(math, argNames);\r\n\r\n    var evalIndex = this.index._compile(math, argNames);\r\n\r\n    if (this.index.isObjectProperty()) {\r\n      var prop = this.index.getObjectProperty();\r\n      return function evalAccessorNode(scope, args, context) {\r\n        // get a property from an object evaluated using the scope.\r\n        return getSafeProperty(evalObject(scope, args, context), prop);\r\n      };\r\n    } else {\r\n      return function evalAccessorNode(scope, args, context) {\r\n        var object = evalObject(scope, args, context);\r\n        var index = evalIndex(scope, args, object); // we pass object here instead of context\r\n\r\n        return access(object, index);\r\n      };\r\n    }\r\n  };\r\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\r\n\r\n\r\n  AccessorNode.prototype.forEach = function (callback) {\r\n    callback(this.object, 'object', this);\r\n    callback(this.index, 'index', this);\r\n  };\r\n  /**\r\n   * Create a new AccessorNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {AccessorNode} Returns a transformed copy of the node\r\n   */\r\n\r\n\r\n  AccessorNode.prototype.map = function (callback) {\r\n    return new AccessorNode(this._ifNode(callback(this.object, 'object', this)), this._ifNode(callback(this.index, 'index', this)));\r\n  };\r\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {AccessorNode}\r\n   */\r\n\r\n\r\n  AccessorNode.prototype.clone = function () {\r\n    return new AccessorNode(this.object, this.index);\r\n  };\r\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string}\r\n   */\r\n\r\n\r\n  AccessorNode.prototype._toString = function (options) {\r\n    var object = this.object.toString(options);\r\n\r\n    if (needParenthesis(this.object)) {\r\n      object = '(' + object + ')';\r\n    }\r\n\r\n    return object + this.index.toString(options);\r\n  };\r\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string}\r\n   */\r\n\r\n\r\n  AccessorNode.prototype.toHTML = function (options) {\r\n    var object = this.object.toHTML(options);\r\n\r\n    if (needParenthesis(this.object)) {\r\n      object = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + object + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n    }\r\n\r\n    return object + this.index.toHTML(options);\r\n  };\r\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string}\r\n   */\r\n\r\n\r\n  AccessorNode.prototype._toTex = function (options) {\r\n    var object = this.object.toTex(options);\r\n\r\n    if (needParenthesis(this.object)) {\r\n      object = '\\\\left(\\' + object + \\'\\\\right)';\r\n    }\r\n\r\n    return object + this.index.toTex(options);\r\n  };\r\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  AccessorNode.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'AccessorNode',\r\n      object: this.object,\r\n      index: this.index\r\n    };\r\n  };\r\n  /**\r\n   * Instantiate an AccessorNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"AccessorNode\", object: ..., index: ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {AccessorNode}\r\n   */\r\n\r\n\r\n  AccessorNode.fromJSON = function (json) {\r\n    return new AccessorNode(json.object, json.index);\r\n  };\r\n  /**\r\n   * Are parenthesis needed?\r\n   * @private\r\n   */\r\n\r\n\r\n  function needParenthesis(node) {\r\n    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?\r\n    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));\r\n  }\r\n\r\n  return AccessorNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}