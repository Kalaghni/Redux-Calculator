{"ast":null,"code":"// function utils\nimport { lruQueue } from './lruQueue.js';\n/**\r\n * Memoize a given function by caching the computed result.\r\n * The cache of a memoized function can be cleared by deleting the `cache`\r\n * property of the function.\r\n *\r\n * @param {function} fn                     The function to be memoized.\r\n *                                          Must be a pure function.\r\n * @param {Object} [options]\r\n * @param {function(args: Array): string} [options.hasher]\r\n *    A custom hash builder. Is JSON.stringify by default.\r\n * @param {number | undefined} [options.limit]\r\n *    Maximum number of values that may be cached. Undefined indicates\r\n *    unlimited (default)\r\n * @return {function}                       Returns the memoized function\r\n */\n\nexport function memoize(fn) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      hasher = _ref.hasher,\n      limit = _ref.limit;\n\n  limit = limit == null ? Number.POSITIVE_INFINITY : limit;\n  hasher = hasher == null ? JSON.stringify : hasher;\n  return function memoize() {\n    if (typeof memoize.cache !== 'object') {\n      memoize.cache = {\n        values: new Map(),\n        lru: lruQueue(limit || Number.POSITIVE_INFINITY)\n      };\n    }\n\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var hash = hasher(args);\n\n    if (memoize.cache.values.has(hash)) {\n      memoize.cache.lru.hit(hash);\n      return memoize.cache.values.get(hash);\n    }\n\n    var newVal = fn.apply(fn, args);\n    memoize.cache.values.set(hash, newVal);\n    memoize.cache.values.delete(memoize.cache.lru.hit(hash));\n    return newVal;\n  };\n}\n/**\r\n * Memoize a given function by caching all results and the arguments,\r\n * and comparing against the arguments of previous results before\r\n * executing again.\r\n * This is less performant than `memoize` which calculates a hash,\r\n * which is very fast to compare. Use `memoizeCompare` only when it is\r\n * not possible to create a unique serializable hash from the function\r\n * arguments.\r\n * The isEqual function must compare two sets of arguments\r\n * and return true when equal (can be a deep equality check for example).\r\n * @param {function} fn\r\n * @param {function(a: *, b: *) : boolean} isEqual\r\n * @returns {function}\r\n */\n\nexport function memoizeCompare(fn, isEqual) {\n  var memoize = function memoize() {\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    for (var c = 0; c < memoize.cache.length; c++) {\n      var cached = memoize.cache[c];\n\n      if (isEqual(args, cached.args)) {\n        // TODO: move this cache entry to the top so recently used entries move up?\n        return cached.res;\n      }\n    }\n\n    var res = fn.apply(fn, args);\n    memoize.cache.unshift({\n      args: args,\n      res: res\n    });\n    return res;\n  };\n\n  memoize.cache = [];\n  return memoize;\n}\n/**\r\n * Find the maximum number of arguments expected by a typed function.\r\n * @param {function} fn   A typed function\r\n * @return {number} Returns the maximum number of expected arguments.\r\n *                  Returns -1 when no signatures where found on the function.\r\n */\n\nexport function maxArgumentCount(fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n}","map":{"version":3,"names":["lruQueue","memoize","fn","arguments","length","undefined","hasher","limit","Number","POSITIVE_INFINITY","JSON","stringify","cache","values","Map","lru","args","i","hash","has","hit","get","newVal","apply","set","delete","memoizeCompare","isEqual","c","cached","res","unshift","maxArgumentCount","Object","keys","signatures","reduce","signature","count","match","Math","max"],"sources":["C:/laragon/www/testsite.thewateringcan/wp-content/plugins/Redux-Calculator/node_modules/mathjs/lib/esm/utils/function.js"],"sourcesContent":["// function utils\r\nimport { lruQueue } from './lruQueue.js';\r\n/**\r\n * Memoize a given function by caching the computed result.\r\n * The cache of a memoized function can be cleared by deleting the `cache`\r\n * property of the function.\r\n *\r\n * @param {function} fn                     The function to be memoized.\r\n *                                          Must be a pure function.\r\n * @param {Object} [options]\r\n * @param {function(args: Array): string} [options.hasher]\r\n *    A custom hash builder. Is JSON.stringify by default.\r\n * @param {number | undefined} [options.limit]\r\n *    Maximum number of values that may be cached. Undefined indicates\r\n *    unlimited (default)\r\n * @return {function}                       Returns the memoized function\r\n */\r\n\r\nexport function memoize(fn) {\r\n  var {\r\n    hasher,\r\n    limit\r\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  limit = limit == null ? Number.POSITIVE_INFINITY : limit;\r\n  hasher = hasher == null ? JSON.stringify : hasher;\r\n  return function memoize() {\r\n    if (typeof memoize.cache !== 'object') {\r\n      memoize.cache = {\r\n        values: new Map(),\r\n        lru: lruQueue(limit || Number.POSITIVE_INFINITY)\r\n      };\r\n    }\r\n\r\n    var args = [];\r\n\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      args[i] = arguments[i];\r\n    }\r\n\r\n    var hash = hasher(args);\r\n\r\n    if (memoize.cache.values.has(hash)) {\r\n      memoize.cache.lru.hit(hash);\r\n      return memoize.cache.values.get(hash);\r\n    }\r\n\r\n    var newVal = fn.apply(fn, args);\r\n    memoize.cache.values.set(hash, newVal);\r\n    memoize.cache.values.delete(memoize.cache.lru.hit(hash));\r\n    return newVal;\r\n  };\r\n}\r\n/**\r\n * Memoize a given function by caching all results and the arguments,\r\n * and comparing against the arguments of previous results before\r\n * executing again.\r\n * This is less performant than `memoize` which calculates a hash,\r\n * which is very fast to compare. Use `memoizeCompare` only when it is\r\n * not possible to create a unique serializable hash from the function\r\n * arguments.\r\n * The isEqual function must compare two sets of arguments\r\n * and return true when equal (can be a deep equality check for example).\r\n * @param {function} fn\r\n * @param {function(a: *, b: *) : boolean} isEqual\r\n * @returns {function}\r\n */\r\n\r\nexport function memoizeCompare(fn, isEqual) {\r\n  var memoize = function memoize() {\r\n    var args = [];\r\n\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      args[i] = arguments[i];\r\n    }\r\n\r\n    for (var c = 0; c < memoize.cache.length; c++) {\r\n      var cached = memoize.cache[c];\r\n\r\n      if (isEqual(args, cached.args)) {\r\n        // TODO: move this cache entry to the top so recently used entries move up?\r\n        return cached.res;\r\n      }\r\n    }\r\n\r\n    var res = fn.apply(fn, args);\r\n    memoize.cache.unshift({\r\n      args,\r\n      res\r\n    });\r\n    return res;\r\n  };\r\n\r\n  memoize.cache = [];\r\n  return memoize;\r\n}\r\n/**\r\n * Find the maximum number of arguments expected by a typed function.\r\n * @param {function} fn   A typed function\r\n * @return {number} Returns the maximum number of expected arguments.\r\n *                  Returns -1 when no signatures where found on the function.\r\n */\r\n\r\nexport function maxArgumentCount(fn) {\r\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\r\n    var count = (signature.match(/,/g) || []).length + 1;\r\n    return Math.max(args, count);\r\n  }, -1);\r\n}"],"mappings":"AAAA;AACA,SAASA,QAAT,QAAyB,eAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,OAAT,CAAiBC,EAAjB,EAAqB;EAC1B,WAGIC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAHxE;EAAA,IACEG,MADF,QACEA,MADF;EAAA,IAEEC,KAFF,QAEEA,KAFF;;EAIAA,KAAK,GAAGA,KAAK,IAAI,IAAT,GAAgBC,MAAM,CAACC,iBAAvB,GAA2CF,KAAnD;EACAD,MAAM,GAAGA,MAAM,IAAI,IAAV,GAAiBI,IAAI,CAACC,SAAtB,GAAkCL,MAA3C;EACA,OAAO,SAASL,OAAT,GAAmB;IACxB,IAAI,OAAOA,OAAO,CAACW,KAAf,KAAyB,QAA7B,EAAuC;MACrCX,OAAO,CAACW,KAAR,GAAgB;QACdC,MAAM,EAAE,IAAIC,GAAJ,EADM;QAEdC,GAAG,EAAEf,QAAQ,CAACO,KAAK,IAAIC,MAAM,CAACC,iBAAjB;MAFC,CAAhB;IAID;;IAED,IAAIO,IAAI,GAAG,EAAX;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,SAAS,CAACC,MAA9B,EAAsCa,CAAC,EAAvC,EAA2C;MACzCD,IAAI,CAACC,CAAD,CAAJ,GAAUd,SAAS,CAACc,CAAD,CAAnB;IACD;;IAED,IAAIC,IAAI,GAAGZ,MAAM,CAACU,IAAD,CAAjB;;IAEA,IAAIf,OAAO,CAACW,KAAR,CAAcC,MAAd,CAAqBM,GAArB,CAAyBD,IAAzB,CAAJ,EAAoC;MAClCjB,OAAO,CAACW,KAAR,CAAcG,GAAd,CAAkBK,GAAlB,CAAsBF,IAAtB;MACA,OAAOjB,OAAO,CAACW,KAAR,CAAcC,MAAd,CAAqBQ,GAArB,CAAyBH,IAAzB,CAAP;IACD;;IAED,IAAII,MAAM,GAAGpB,EAAE,CAACqB,KAAH,CAASrB,EAAT,EAAac,IAAb,CAAb;IACAf,OAAO,CAACW,KAAR,CAAcC,MAAd,CAAqBW,GAArB,CAAyBN,IAAzB,EAA+BI,MAA/B;IACArB,OAAO,CAACW,KAAR,CAAcC,MAAd,CAAqBY,MAArB,CAA4BxB,OAAO,CAACW,KAAR,CAAcG,GAAd,CAAkBK,GAAlB,CAAsBF,IAAtB,CAA5B;IACA,OAAOI,MAAP;EACD,CAzBD;AA0BD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASI,cAAT,CAAwBxB,EAAxB,EAA4ByB,OAA5B,EAAqC;EAC1C,IAAI1B,OAAO,GAAG,SAASA,OAAT,GAAmB;IAC/B,IAAIe,IAAI,GAAG,EAAX;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,SAAS,CAACC,MAA9B,EAAsCa,CAAC,EAAvC,EAA2C;MACzCD,IAAI,CAACC,CAAD,CAAJ,GAAUd,SAAS,CAACc,CAAD,CAAnB;IACD;;IAED,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3B,OAAO,CAACW,KAAR,CAAcR,MAAlC,EAA0CwB,CAAC,EAA3C,EAA+C;MAC7C,IAAIC,MAAM,GAAG5B,OAAO,CAACW,KAAR,CAAcgB,CAAd,CAAb;;MAEA,IAAID,OAAO,CAACX,IAAD,EAAOa,MAAM,CAACb,IAAd,CAAX,EAAgC;QAC9B;QACA,OAAOa,MAAM,CAACC,GAAd;MACD;IACF;;IAED,IAAIA,GAAG,GAAG5B,EAAE,CAACqB,KAAH,CAASrB,EAAT,EAAac,IAAb,CAAV;IACAf,OAAO,CAACW,KAAR,CAAcmB,OAAd,CAAsB;MACpBf,IAAI,EAAJA,IADoB;MAEpBc,GAAG,EAAHA;IAFoB,CAAtB;IAIA,OAAOA,GAAP;EACD,CAtBD;;EAwBA7B,OAAO,CAACW,KAAR,GAAgB,EAAhB;EACA,OAAOX,OAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS+B,gBAAT,CAA0B9B,EAA1B,EAA8B;EACnC,OAAO+B,MAAM,CAACC,IAAP,CAAYhC,EAAE,CAACiC,UAAH,IAAiB,EAA7B,EAAiCC,MAAjC,CAAwC,UAAUpB,IAAV,EAAgBqB,SAAhB,EAA2B;IACxE,IAAIC,KAAK,GAAG,CAACD,SAAS,CAACE,KAAV,CAAgB,IAAhB,KAAyB,EAA1B,EAA8BnC,MAA9B,GAAuC,CAAnD;IACA,OAAOoC,IAAI,CAACC,GAAL,CAASzB,IAAT,EAAesB,KAAf,CAAP;EACD,CAHM,EAGJ,CAAC,CAHG,CAAP;AAID"},"metadata":{},"sourceType":"module"}